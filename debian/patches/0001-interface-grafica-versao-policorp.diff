Index: guvcview/debian/rules
===================================================================
--- guvcview.orig/debian/rules
+++ guvcview/debian/rules
@@ -9,6 +9,7 @@ override_dh_auto_configure:
 		--prefix=/usr \
 		--libdir=\$${prefix}/lib/$(DEB_HOST_MULTIARCH) \
 		GVIEWENCODER_CFLAGS="-D_FILE_OFFSET_BITS=64" \
+		GVIEWRENDER_LIBS="-lSDL2 -lSDL2_ttf -lSDL2_image" \
 		--disable-debian-menu
 
 override_dh_install:
Index: guvcview/gview_render/render_sdl2.c
===================================================================
--- guvcview.orig/gview_render/render_sdl2.c
+++ guvcview/gview_render/render_sdl2.c
@@ -32,15 +32,29 @@
 #include "render.h"
 #include "render_sdl2.h"
 #include "../config.h"
+#include <SDL2/SDL.h>
+#include <SDL2/SDL_ttf.h>
+#include <stdio.h>
+#include <pthread.h>
+#include <SDL2/SDL_thread.h>
+#include <SDL2/SDL_image.h>
+#include "guvcview/core_io.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+#define BUFFER_SIZE 128
 
 extern int render_verbosity;
 
 SDL_DisplayMode display_mode;
 
-static SDL_Window*  sdl_window = NULL;
-static SDL_Texture* rending_texture = NULL;
-static SDL_Renderer*  main_renderer = NULL;
-
+SDL_Window*  sdl_window = NULL;
+SDL_Texture* rending_texture = NULL;
+SDL_Renderer*  main_renderer = NULL;
+SDL_Renderer*  renderer = NULL;
+SDL_Surface *windowSurface = NULL;
+SDL_Surface *imageSurface = NULL;
 /*
  * initialize sdl video
  * args:
@@ -58,6 +72,165 @@ static SDL_Renderer*  main_renderer = NU
  *
  * returns: error code
  */
+
+int gravando = 1;
+
+typedef struct {
+     const char* path;
+     int width;
+     int height;
+     int x;
+     int y;
+} ImageInfo;
+
+int valorX = 18;
+int valorxGaleria = 17;
+int valoryVideo = 207;
+int valoryCamera = 130;
+int valoryGaleria = 406; 
+
+
+void createImage(const ImageInfo images[], int numImages) {
+     SDL_Rect* destRects = (SDL_Rect*)malloc(numImages * sizeof(SDL_Rect));
+     SDL_Texture** textures = (SDL_Texture**)malloc(numImages * sizeof(SDL_Texture*));
+
+     for (int i = 0; i < numImages; ++i) {
+         SDL_Surface* surface = IMG_Load(images[i].path);
+         textures[i] = SDL_CreateTextureFromSurface(main_renderer, surface);
+         SDL_FreeSurface(surface);
+
+         destRects[i].w = images[i].width;
+         destRects[i].h = images[i].height;
+         destRects[i].x = images[i].x;
+         destRects[i].y = images[i].y;
+
+     }
+
+     for (int i = 0; i < numImages; ++i) {
+         SDL_RenderCopy(main_renderer, textures[i], NULL, &destRects[i]);
+     }
+
+     free(destRects);
+     free(textures);
+}
+void setHandCursor(SDL_Window* window) {
+     SDL_Cursor *handCursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
+     SDL_SetCursor(handCursor);
+     SDL_FreeCursor(handCursor);
+}
+// Função para verificar se um ponto (x, y) está dentro de um retângulo definido por (rectX, rectY, rectWidth, rectHeight)
+ int isPointInsideRect(int x, int y, int rectX, int rectY, int rectWidth, int rectHeight) {
+     return (x >= rectX && x <= (rectX + rectWidth) && y >= rectY && y <= (rectY + rectHeight));
+}
+
+// Função para lidar com o clique em uma imagem com base no índice
+ void handleImageClick(int index) {
+     switch (index) {
+         case 0:
+             onRecordButtonClick();
+             break;
+         case 1:
+             onPhotoButtonClick();
+             break;
+         case 2:
+             onGalleryButtonClick();
+             break;
+         default:
+             break;
+     }
+}
+
+// Função para tratar o clique no botão "FOTO"
+void onPhotoButtonClick() {
+     printf("Clicou no botão FOTO!\n");
+
+     render_call_event_callback(EV_KEY_I);
+	ImageInfo images[] = {
+        { "/usr/share/pixmaps/guvcview/camera-clique.svg", 50, 50, valorX, valoryCamera },
+	};
+
+    createImage(images, sizeof(images) / sizeof(images[0]));
+    SDL_RenderPresent(main_renderer);
+    SDL_Delay(400);
+}
+
+ // Função para tratar o clique no botão "GRAVAR"
+ void onRecordButtonClick() {
+     printf("Clicou no botão GRAVAR!\n");
+     render_call_event_callback(EV_KEY_V);
+    
+     ImageInfo images[] = {
+        { "/usr/share/pixmaps/guvcview/video-clique.svg", 50, 50, valorX, valoryVideo },
+	};
+    createImage(images, sizeof(images) / sizeof(images[0]));
+    SDL_RenderPresent(main_renderer);
+    if (gravando == 0){
+    	gravando = 1;
+    } else {
+	gravando = 0;
+    }    
+    SDL_Delay(300);
+}
+
+void onGalleryButtonClick() {
+     printf("Clicou no botão GALERIA!\n");
+     const char *homeDir = getenv("HOME");
+
+     if (homeDir == NULL){
+         perror("Erro ao obter HOME");
+         return;
+     }
+     char arquivoConfig[256];
+     snprintf(arquivoConfig, sizeof(arquivoConfig), "%s/.config/guvcview2/video0", homeDir);
+     FILE *arquivo = fopen(arquivoConfig, "r");
+
+     if (arquivo == NULL) {
+            perror("Erro ao abrir o arquivo de configuração na primeira\n");
+	    config_save(arquivoConfig);
+    	    arquivo = fopen(arquivoConfig, "r");
+            perror("Arquivo foi criado\n");
+     }
+
+     char linha[256];
+
+     while (fgets(linha, sizeof(linha), arquivo) != NULL) {
+         if (sscanf(linha, "photo_path=%s", linha) == 1) {
+             printf("Caminho da foto: %s\n", linha);
+
+             // Criar um novo processo
+             pid_t pid = fork();
+
+             if (pid == -1) {
+                 perror("Erro ao criar processo");
+                 break;
+            } else if (pid == 0) {  // Processo filho
+                 // Executar o comando no processo filho
+                 execlp("nautilus", "nautilus", linha, (char *)NULL);
+
+                 // Se o execlp falhar, imprime um erro
+                 perror("Erro ao executar nautilus");
+                 exit(EXIT_FAILURE);
+                 waitpid(pid, NULL, 0);
+                 break;  // Se você quiser apenas a primeira ocorrência, pode sair do loop
+             }
+         }
+     }
+
+     //// apenas a galeria é trocado
+     ImageInfo images[] = {
+	{ "/usr/share/pixmaps/guvcview/video.svg", 50, 50, valorX, valoryVideo },
+        { "/usr/share/pixmaps/guvcview/camera.svg", 50, 50, valorX, valoryCamera },
+        { "/usr/share/pixmaps/guvcview/galeria-clique.svg", 30, 30, valorxGaleria, valoryGaleria },
+	};
+
+    createImage(images, sizeof(images) / sizeof(images[0]));
+    SDL_RenderPresent(main_renderer);
+    SDL_Delay(150);
+
+
+     fclose(arquivo);
+ }
+
 static int video_init(int width, int height, int flags, int win_w, int win_h)
 {
 	int w = width;
@@ -281,6 +454,7 @@ static int video_init(int width, int hei
  *
  * returns: error code
  */
+
 int render_sdl2_frame(uint8_t *frame, int width, int height)
 {
 	/*asserts*/
@@ -298,6 +472,50 @@ int render_sdl2_frame(uint8_t *frame, in
 
 	SDL_RenderCopy(main_renderer, rending_texture, NULL, NULL);
 
+	ImageInfo images[] = {
+        { "/usr/share/pixmaps/guvcview/video.svg", 50, 50, valorX, valoryVideo },
+        { "/usr/share/pixmaps/guvcview/camera.svg", 50, 50, valorX, valoryCamera },
+        { "/usr/share/pixmaps/guvcview/galeria.svg", 30, 30, valorxGaleria, valoryGaleria },
+    	};
+
+	if (gravando == 0) {
+    		images[0].path = "/usr/share/pixmaps/guvcview/video-clique.svg";
+	} else {
+    		images[0].path = "/usr/share/pixmaps/guvcview/video.svg";
+	}
+
+	SDL_Event event;
+	while (SDL_PollEvent(&event)) {
+	if (event.type == SDL_MOUSEMOTION) {
+        	// Verifica se o mouse está sobre a área clicável
+        	for (int i = 0; i < sizeof(images) / sizeof(images[0]); ++i) {
+            	if (isPointInsideRect(event.motion.x, event.motion.y, images[i].x, images[i].y, images[i].width, images[i].height)) {
+                	// Configura o cursor para a mão
+                	setHandCursor(sdl_window);
+                	break;
+            	} else {
+                	// Configura o cursor para o padrão
+                	SDL_SetCursor(NULL);
+            	}
+        	}
+    	}
+    	if (event.type == SDL_MOUSEBUTTONDOWN && (event.button.button & SDL_BUTTON_LEFT)) {
+        	int mouseX = event.button.x;
+        	int mouseY = event.button.y;
+
+	        for (int i = 0; i < sizeof(images) / sizeof(images[0]); ++i) {
+        	    if (isPointInsideRect(mouseX, mouseY, images[i].x, images[i].y, images[i].width, images[i].height)) {
+                	printf("Clicou na imagem %d\n", i);
+                	handleImageClick(i);
+                	break;
+            	}
+        	}
+    	}
+	if(event.type==SDL_QUIT) {
+		render_call_event_callback(EV_QUIT);
+	}
+	}
+    	createImage(images, sizeof(images) / sizeof(images[0]));
 	SDL_RenderPresent(main_renderer);
 
 	return 0;
